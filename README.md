# üî¢Math Expression Evaluator

## üîçOverview
The Math Expression Evaluator is a command-line application designed to parse and evaluate mathematical expressions provided as input strings. It supports basic arithmetic operations, mathematical functions, and evaluation of expressions containing both integer and double values.

## üõ†Ô∏è Dependencies

- C++ compiler supporting C++11 or later
- Standard library headers
- `<map>` header for LUT generation

## üöÄ Building the Project

To build the Math Expression Evaluator, follow these steps:

1. Clone the repository:

    ```bash
    git clone https://github.com/xxEBxx/Math_eval.git
    ```

2. Navigate to the project directory:

    ```bash
    cd Math_eval
    ```

3. Build the project (you may skip this step):

    ```bash
    make build
    ```

## Running the Application

To run the Math Expression Evaluator, use the following command:

```bash
binary 
```
After enter you will get this format :
```bash
Enter your expression: 'expression'
```
Replace 'expression' with the math expression you want to evaluate (without the single quotes).

# üìã Design Overview
## Tokenization and Syntax Parsing
The project starts with tokenization and syntax parsing of the input expression. The `tokenize` function breaks down the input string into tokens, while the `parse_syntax` function verifies the syntax of the tokenized expression to ensure it adheres to expected patterns.

## Conversion to Postfix Notation
After tokenization and syntax parsing, the expression is converted into postfix notation using the `to_postfix` function. Postfix notation facilitates efficient evaluation of mathematical expressions.

## Evaluation of Postfix Expression
The core of the project lies in the calculate function, which evaluates the postfix expression generated from the tokenized input. It utilizes various implemented mathematical functions such as `to_sin`, `to_cose`, `to_tan`, `to_asin`, `to_acos`, `to_atan`, `to_sqrt`, and `to_pow` functions to compute the result.

## Lookup Table Generation
To enhance the efficiency of trigonometric function evaluations, the project includes the generation of Lookup Tables (LUTs) for sine, cosine, and arcsine functions. These LUTs are pre-generated in the [LUT Definition](https://github.com/xxEBxx/Math_eval/blob/main/LUT/LUT_definition.h)
 file, this file was generated by the [LUT_generator](https://github.com/xxEBxx/Math_eval/blob/main/LUT/Look_Up_Table_generator.cpp) file.

# ‚öñÔ∏èTradeoffs and Considerations
## Efficiency vs. Accuracy
In this implementation, efficiency takes precedence by utilizing Lookup Tables (LUTs) for trigonometric functions. While this approach significantly enhances performance, it may introduce minor inaccuracies due to interpolation during the lookup process. However, the tradeoff between efficiency and accuracy was carefully considered and deemed acceptable for most practical use cases.

## Memory Usage
The project employs maps for storing Lookup Tables, ensuring efficient access to precomputed function values. However, it's important to note that this approach may lead to increased memory consumption, particularly for large step sizes in LUT generation. Nevertheless, this tradeoff was made to optimize runtime performance and ensure swift evaluation of expressions.

## Error Handling
Robust error handling mechanisms have been integrated into the project to detect and report various types of errors, including syntax errors, division by zero, and other invalid expressions. By providing informative error messages, the application enhances usability and facilitates a smoother user experience.

# üåÄto_atan and to_pow: Unique Implementations (I guess)

In this section, I'll discuss two key functions, `to_atan` and `to_pow`, which deviate from conventional approaches and showcase innovative implementations.

## to_atan:

The `atan` function typically operates on the domain ‚Ñù and maps to the range (-œÄ/2, œÄ/2). Due to the expansive domain of ‚Ñù, employing a lookup table becomes impractical. As a result, I employed an alternative approach.

For elements within the range [0, 1], I utilized a rational approximation technique, yielding satisfactory results within this interval. However, beyond this range, the approximation diverged. To address this limitation, I exploited the properties of `atan`: its even nature and the identity `atan(x) + atan(1/x) = œÄ/2`. Leveraging these properties, I extended the function's applicability to all real numbers, ensuring good accuracy across the entire domain.

## to_pow:

The `to_pow` function posed unique challenges, particularly in computing fractional powers of numbers. While integer exponentiation presented a straightforward solution, handling fractional exponents required a different approach.

To approximate fractional components (e.g., 0.xxx), I employed a binary search-like strategy. By iteratively applying multiplication, division, or none(just waiting for next iteration) operations, I fine-tuned the approximation until achieving the desired precision. This approach facilitated accurate computation of non-integer powers, offering versatility in handling a wide range of mathematical expressions.

By employing these innovative techniques, the `to_atan` and `to_pow` functions (found at [4functions.h](https://github.com/xxEBxx/Math_eval/blob/main/4functions.h)) provide efficient and accurate solutions, enhancing the overall effectiveness of the Math Expression Evaluator.


# üéâConclusion
The Math Expression Evaluator offers a versatile and efficient solution for evaluating mathematical expressions from the command line. By adhering to the specified evaluation criteria and leveraging Lookup Tables for trigonometric functions, it strikes a balance between accuracy and performance, catering to a wide range of mathematical computations.

If you have any further questions or need additional assistance, feel free to reach out.







